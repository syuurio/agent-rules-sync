#!/usr/bin/env bash

# Agent Rules Sync - Unified configuration management for AI agents
# Version: 1.0.0
# License: MIT
# Repository: https://github.com/syuurio/agent-rules-sync

set -euo pipefail

# Version information
VERSION="1.0.0"

# Configuration
BACKUP_RETENTION_COUNT=5

# Global menu result variables (initialized to avoid unbound variable errors)
MENU_RESULT=0
MULTI_SELECT_RESULT=""

# Resolve symlinks to get the real script directory
# This ensures paths work correctly when invoked via symlink
resolve_script_dir() {
    local source="${BASH_SOURCE[0]}"
    while [[ -L "$source" ]]; do
        local dir="$(cd -P "$(dirname "$source")" && pwd)"
        source="$(readlink "$source")"
        # If source was a relative symlink, resolve it relative to the symlink's directory
        [[ "$source" != /* ]] && source="$dir/$source"
    done
    cd -P "$(dirname "$source")" && pwd
}

SCRIPT_DIR="$(resolve_script_dir)"
SOURCE_FILE="${SCRIPT_DIR}/../AGENTS.md"

# Color output functions
color_red() { echo -e "\033[0;31m$*\033[0m"; }
color_green() { echo -e "\033[0;32m$*\033[0m"; }
color_yellow() { echo -e "\033[0;33m$*\033[0m"; }
color_blue() { echo -e "\033[0;34m$*\033[0m"; }
color_bold() { echo -e "\033[1m$*\033[0m"; }

# Status message functions
success() { color_green "✓ $*"; }
error() { color_red "✗ $*"; }
warning() { color_yellow "⚠ $*"; }
info() { color_blue "ℹ $*"; }

# Tool configuration
# Get tool config path by name
get_tool_path() {
    case "$1" in
        claude)
            echo "$HOME/.claude/CLAUDE.md"
            ;;
        windsurf)
            echo "$HOME/.codeium/windsurf/memories/global_rules.md"
            ;;
        gemini)
            echo "$HOME/.gemini/GEMINI.md"
            ;;
        antigravity)
            echo "$HOME/.gemini/antigravity/AGENTS.md"
            ;;
        codex)
            echo "$HOME/.codex/AGENTS.md"
            ;;
        *)
            return 1
            ;;
    esac
}

# List of all supported tools
ALL_TOOLS=("claude" "windsurf" "gemini" "antigravity" "codex")

# Flags
DRY_RUN=false
VERBOSE=false
NO_BACKUP=false
SPECIFIC_TOOL=""
RESTORE_MODE=false
LIST_BACKUPS_MODE=false
SYNC_ALL=false  # Skip interactive menu and sync all tools

# Display usage information
show_usage() {
    cat << EOF
$(color_bold "Agent Rules Sync v${VERSION}")

A unified configuration management tool for AI agent rules across multiple platforms.

$(color_bold "USAGE:")
    agent-rules-sync [OPTIONS]

$(color_bold "OPTIONS:")
    --help              Show this help message
    --version           Display version information
    --list-tools        List all supported tools
    --list-backups      List available backups for all tools
    --all               Sync to all tools without interactive menu
    --dry-run           Preview operations without executing
    --verbose           Show detailed output
    --tool <name>       Sync/restore specific tool only
    --source <path>     Specify custom source file (default: AGENTS.md)
    --no-backup         Skip backup before overwriting
    --restore           Restore from backup (interactive)

$(color_bold "EXAMPLES:")
    agent-rules-sync                    # Interactive: select tools to sync
    agent-rules-sync --all              # Sync to all tools
    agent-rules-sync --dry-run          # Preview with interactive selection
    agent-rules-sync --all --dry-run    # Preview syncing all tools
    agent-rules-sync --tool claude      # Sync to Claude Code only
    agent-rules-sync --verbose          # Show detailed sync process
    agent-rules-sync --restore          # Restore from backup (interactive)
    agent-rules-sync --restore --tool claude  # Restore specific tool
    agent-rules-sync --list-backups     # List all available backups

$(color_bold "SUPPORTED TOOLS:")
    $(list_tools | sed 's/^/    /')

$(color_bold "REPOSITORY:")
    https://github.com/syuurio/agent-rules-sync

EOF
}

# Display version information
show_version() {
    echo "Agent Rules Sync v${VERSION}"
    echo "License: MIT"
}

# List all supported tools
list_tools() {
    for tool in "${ALL_TOOLS[@]}"; do
        local config_path="$(get_tool_path "$tool")"
        if [[ -f "$config_path" ]]; then
            echo "$(color_green "●") ${tool} (installed)"
        else
            echo "$(color_yellow "○") ${tool} (not installed)"
        fi
    done
}

# Create backup of existing file
backup_file() {
    local file="$1"
    if [[ -f "$file" ]]; then
        local backup_dir="$(dirname "$file")"
        local backup_name="$(basename "$file").bak.$(date +%Y%m%d_%H%M%S)"
        local backup_path="${backup_dir}/${backup_name}"

        cp "$file" "$backup_path"
        [[ "$VERBOSE" == true ]] && info "Created backup: $backup_path"

        # Keep only the N most recent backups (defined by BACKUP_RETENTION_COUNT)
        # NOTE: Using portable method instead of `head -n -N` because macOS BSD head
        # does not support negative line counts. We calculate the number of files to
        # delete (total - N) and use `head -n $count` which works on both macOS and Linux.
        local backup_pattern="$(basename "$file").bak.*"
        local backup_count=$(find "$backup_dir" -name "$backup_pattern" -type f 2>/dev/null | wc -l | tr -d ' ')
        if [[ $backup_count -gt $BACKUP_RETENTION_COUNT ]]; then
            local backups_to_delete=$((backup_count - BACKUP_RETENTION_COUNT))
            find "$backup_dir" -name "$backup_pattern" -type f 2>/dev/null | \
                sort | head -n "$backups_to_delete" | xargs rm -f 2>/dev/null || true
            [[ "$VERBOSE" == true ]] && info "Cleaned old backups (kept $BACKUP_RETENTION_COUNT most recent)"
        fi
    fi
}

# =============================================================================
# Interactive Menu Helper Functions
# =============================================================================

# Hide terminal cursor
_menu_hide_cursor() {
    tput civis 2>/dev/null || true
}

# Show terminal cursor
_menu_show_cursor() {
    tput cnorm 2>/dev/null || true
}

# Move cursor up N lines (portable for both macOS and Linux)
_menu_cursor_up() {
    local lines=$1
    for ((i = 0; i < lines; i++)); do
        tput cuu1 2>/dev/null || printf '\033[1A'
    done
}

# Read a single key and return arrow key direction or the key itself
# Sets MENU_KEY_RESULT to: "up", "down", "enter", "space", or the actual key
_menu_read_key() {
    local key=""
    MENU_KEY_RESULT=""

    # Read a single character (blocking)
    IFS= read -rsn1 key || true

    # Handle Ctrl+C (ASCII 3)
    if [[ "$key" == $'\x03' ]]; then
        MENU_KEY_RESULT="interrupt"
        return
    fi

    # Handle escape sequences (arrow keys)
    if [[ "$key" == $'\x1b' ]]; then
        local key2="" key3=""
        read -rsn1 key2 || true
        read -rsn1 key3 || true
        case "${key2}${key3}" in
            '[A') MENU_KEY_RESULT="up" ;;
            '[B') MENU_KEY_RESULT="down" ;;
            *)    MENU_KEY_RESULT="escape" ;;
        esac
        return
    fi

    # Handle Enter (empty string after read)
    if [[ "$key" == "" ]]; then
        MENU_KEY_RESULT="enter"
        return
    fi

    # Handle space
    if [[ "$key" == " " ]]; then
        MENU_KEY_RESULT="space"
        return
    fi

    # Return the actual key for other cases
    MENU_KEY_RESULT="$key"
}

# =============================================================================
# Interactive Menu Functions
# =============================================================================

# Interactive menu with arrow key navigation (single select)
# Usage: interactive_menu "prompt" "option1" "option2" "option3" ...
# Returns: selected index (0-based) in $MENU_RESULT, or -1 if cancelled
interactive_menu() {
    local prompt="$1"
    shift
    local options=("$@")
    local cursor=0
    local total=${#options[@]}

    # Hide cursor and ensure it's restored on exit
    _menu_hide_cursor
    trap '_menu_show_cursor' RETURN

    echo "$prompt"
    echo ""

    # Function to print menu
    _print_single_menu() {
        local redraw="${1:-}"

        # Move cursor up to redraw menu
        [[ "$redraw" == "redraw" ]] && _menu_cursor_up "$total"

        for ((i = 0; i < total; i++)); do
            if [[ $i -eq $cursor ]]; then
                printf '  \033[0;32m❯ %s\033[0m\n' "${options[$i]}"
            else
                printf '    %s\n' "${options[$i]}"
            fi
        done
    }

    # Initial print
    _print_single_menu

    # Read input loop
    while true; do
        _menu_read_key

        case "$MENU_KEY_RESULT" in
            up)
                cursor=$((cursor - 1))
                [[ $cursor -lt 0 ]] && cursor=$((total - 1))
                _print_single_menu "redraw"
                ;;
            down)
                cursor=$((cursor + 1))
                [[ $cursor -ge $total ]] && cursor=0
                _print_single_menu "redraw"
                ;;
            enter)
                echo ""
                MENU_RESULT=$cursor
                return 0
                ;;
            interrupt|escape)
                echo ""
                MENU_RESULT=-1
                return 1
                ;;
        esac
    done
}

# Multi-select menu with arrow key navigation and toggle
# Usage: multi_select_menu "prompt" "option1" "option2" ...
# Returns: space-separated selected indices (0-based) in $MULTI_SELECT_RESULT
#          Returns empty string and exit code 1 if cancelled
multi_select_menu() {
    local prompt="$1"
    shift
    local options=("$@")
    local cursor=0
    local total=${#options[@]}
    local selected=()

    # Initialize all as unselected
    for ((i = 0; i < total; i++)); do
        selected[$i]=0
    done

    # Hide cursor and ensure it's restored on exit
    _menu_hide_cursor
    trap '_menu_show_cursor' RETURN

    echo "$prompt"
    echo ""

    # Function to print menu
    _print_multi_menu() {
        local redraw="${1:-}"

        # Move cursor up to redraw menu
        [[ "$redraw" == "redraw" ]] && _menu_cursor_up "$total"

        for ((i = 0; i < total; i++)); do
            local marker="○"
            local color_start=""
            local color_end=""

            if [[ ${selected[$i]} -eq 1 ]]; then
                marker="✓"
                color_start="\033[0;32m"
                color_end="\033[0m"
            fi

            if [[ $i -eq $cursor ]]; then
                printf "  \033[0;32m❯\033[0m ${color_start}${marker} %s${color_end}\n" "${options[$i]}"
            else
                printf "    ${color_start}${marker} %s${color_end}\n" "${options[$i]}"
            fi
        done
    }

    # Initial print
    _print_multi_menu

    # Read input loop
    while true; do
        _menu_read_key

        case "$MENU_KEY_RESULT" in
            up)
                cursor=$((cursor - 1))
                [[ $cursor -lt 0 ]] && cursor=$((total - 1))
                _print_multi_menu "redraw"
                ;;
            down)
                cursor=$((cursor + 1))
                [[ $cursor -ge $total ]] && cursor=0
                _print_multi_menu "redraw"
                ;;
            space)
                # Toggle selection
                if [[ ${selected[$cursor]} -eq 1 ]]; then
                    selected[$cursor]=0
                else
                    selected[$cursor]=1
                fi
                _print_multi_menu "redraw"
                ;;
            a|A)
                # Select all
                for ((i = 0; i < total; i++)); do
                    selected[$i]=1
                done
                _print_multi_menu "redraw"
                ;;
            d|D)
                # Deselect all
                for ((i = 0; i < total; i++)); do
                    selected[$i]=0
                done
                _print_multi_menu "redraw"
                ;;
            enter)
                echo ""
                MULTI_SELECT_RESULT=""
                for ((i = 0; i < total; i++)); do
                    if [[ ${selected[$i]} -eq 1 ]]; then
                        MULTI_SELECT_RESULT="$MULTI_SELECT_RESULT $i"
                    fi
                done
                MULTI_SELECT_RESULT="${MULTI_SELECT_RESULT# }" # trim leading space
                return 0
                ;;
            interrupt|escape)
                echo ""
                MULTI_SELECT_RESULT=""
                return 1
                ;;
        esac
    done
}

# Get list of backup files for a tool (newest first)
# Usage: list_backups_for_tool "tool_name"
# Returns: newline-separated list of backup file paths
list_backups_for_tool() {
    local tool_name="$1"
    local tool_path
    if ! tool_path="$(get_tool_path "$tool_name")"; then
        return 1
    fi

    local backup_dir="$(dirname "$tool_path")"
    local backup_pattern="$(basename "$tool_path").bak.*"

    # Return backups sorted by name (which includes timestamp), newest first
    find "$backup_dir" -name "$backup_pattern" -type f 2>/dev/null | sort -r
}

# Count backup files for a tool
# Usage: count_backups_for_tool "tool_name"
count_backups_for_tool() {
    local tool_name="$1"
    list_backups_for_tool "$tool_name" | wc -l | tr -d ' '
}

# Restore a backup file to the original location
# Usage: restore_backup "tool_name" "backup_path"
restore_backup() {
    local tool_name="$1"
    local backup_path="$2"
    local tool_path
    if ! tool_path="$(get_tool_path "$tool_name")"; then
        error "Unknown tool: $tool_name"
        return 1
    fi

    # Verify backup file exists
    if [[ ! -f "$backup_path" ]]; then
        error "Backup file not found: $backup_path"
        return 1
    fi

    # Backup current file before restoring (safety measure)
    if [[ -f "$tool_path" ]]; then
        backup_file "$tool_path"
        success "Backed up current config"
    fi

    # Perform restore
    if cp "$backup_path" "$tool_path" 2>/dev/null; then
        success "Restored $tool_name from: $(basename "$backup_path")"
        return 0
    else
        error "Failed to restore $tool_name"
        return 1
    fi
}

# List all backups for all tools
list_all_backups() {
    echo ""
    color_bold "Backup Status"
    echo ""

    for tool in "${ALL_TOOLS[@]}"; do
        local count=$(count_backups_for_tool "$tool")
        local tool_path
        if tool_path="$(get_tool_path "$tool")"; then
            if [[ $count -gt 0 ]]; then
                echo "$(color_green "●") $tool ($count backups)"
                if [[ "$VERBOSE" == true ]]; then
                    list_backups_for_tool "$tool" | while read -r backup; do
                        echo "    $(basename "$backup")"
                    done
                fi
            else
                echo "$(color_yellow "○") $tool (no backups)"
            fi
        fi
    done
    echo ""
}

# Main restore flow
run_restore() {
    echo ""
    color_bold "Agent Rules Sync v${VERSION} - Restore"
    echo ""

    # Build list of tools with backups
    local tools_with_backups=()
    local tool_options=()

    for tool in "${ALL_TOOLS[@]}"; do
        local count=$(count_backups_for_tool "$tool")
        if [[ $count -gt 0 ]]; then
            tools_with_backups+=("$tool")
            tool_options+=("$tool ($count backups)")
        fi
    done

    if [[ ${#tools_with_backups[@]} -eq 0 ]]; then
        warning "No backups found for any tool"
        info "Backups are created automatically when syncing"
        exit 0
    fi

    # If specific tool is provided via --tool flag
    if [[ -n "$SPECIFIC_TOOL" ]]; then
        local count=$(count_backups_for_tool "$SPECIFIC_TOOL")
        if [[ $count -eq 0 ]]; then
            error "No backups found for $SPECIFIC_TOOL"
            exit 1
        fi
        restore_tool "$SPECIFIC_TOOL"
        return
    fi

    # Interactive tool selection
    if ! multi_select_menu "Select tools to restore (↑↓ move, Space toggle, a=all, d=none, Enter confirm, Esc cancel):" "${tool_options[@]}"; then
        info "Restore cancelled"
        exit 0
    fi

    if [[ -z "$MULTI_SELECT_RESULT" ]]; then
        info "No tools selected"
        exit 0
    fi

    # Process each selected tool
    local success_count=0
    local failure_count=0

    for idx in $MULTI_SELECT_RESULT; do
        local tool="${tools_with_backups[$idx]}"
        echo ""
        color_bold "Restoring $tool..."

        if restore_tool "$tool"; then
            ((success_count++))
        else
            ((failure_count++))
        fi
    done

    # Display summary
    echo ""
    color_bold "Restore Summary:"
    echo "  $(color_green "Success: $success_count")"
    [[ $failure_count -gt 0 ]] && echo "  $(color_red "Failed: $failure_count")"
    echo ""

    [[ $failure_count -eq 0 ]] && exit 0 || exit 1
}

# Restore a single tool (with backup selection)
restore_tool() {
    local tool_name="$1"

    # Get list of backups
    local backups=()
    local backup_options=()
    local first=true

    while IFS= read -r backup; do
        [[ -z "$backup" ]] && continue
        backups+=("$backup")
        local basename_backup="$(basename "$backup")"
        if [[ "$first" == true ]]; then
            backup_options+=("$basename_backup (newest)")
            first=false
        else
            backup_options+=("$basename_backup")
        fi
    done < <(list_backups_for_tool "$tool_name")

    if [[ ${#backups[@]} -eq 0 ]]; then
        error "No backups found for $tool_name"
        return 1
    fi

    # If only one backup, use it directly
    if [[ ${#backups[@]} -eq 1 ]]; then
        info "Only one backup available, using it"
        restore_backup "$tool_name" "${backups[0]}"
        return $?
    fi

    # Interactive backup selection
    if ! interactive_menu "Select backup to restore (↑↓ move, Enter confirm, Esc cancel):" "${backup_options[@]}"; then
        info "Restore cancelled for $tool_name"
        return 1
    fi

    local selected_backup="${backups[$MENU_RESULT]}"
    restore_backup "$tool_name" "$selected_backup"
}

# Sync to a specific tool
sync_to_tool() {
    local tool_name="$1"
    local target_path="$2"
    local target_dir="$(dirname "$target_path")"

    # Create target directory if it doesn't exist
    if [[ ! -d "$target_dir" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            info "[DRY RUN] Would create directory: $target_dir"
        else
            if mkdir -p "$target_dir" 2>/dev/null; then
                [[ "$VERBOSE" == true ]] && info "Created directory: $target_dir"
            else
                error "Failed to create directory: $target_dir (permission denied)"
                return 1
            fi
        fi
    fi

    # Check if target directory is writable
    if [[ ! -w "$target_dir" ]] && [[ "$DRY_RUN" == false ]]; then
        error "No write permission for: $target_dir"
        warning "Try running: chmod u+w $target_dir"
        return 1
    fi

    # Perform sync
    if [[ "$DRY_RUN" == true ]]; then
        info "[DRY RUN] Would sync to: $target_path"
    else
        # Backup existing file
        if [[ "$NO_BACKUP" == false ]] && [[ -f "$target_path" ]]; then
            backup_file "$target_path"
        fi

        # Copy file
        if cp "$SOURCE_FILE" "$target_path" 2>/dev/null; then
            success "Synced to ${tool_name}: $target_path"
        else
            error "Failed to sync to ${tool_name}: $target_path"
            return 1
        fi
    fi

    return 0
}

# Special handling for Cursor (SQLite database)
handle_cursor() {
    warning "Cursor uses SQLite database for global rules"
    echo ""
    echo "  Manual update required:"
    echo "  1. Open Cursor"
    echo "  2. Open Cursor Settings (Cmd+Shift+J or Ctrl+Shift+J)"
    echo "  3. Navigate to: Rules and Commands > User Rules"
    echo "  4. Click 'Add Rule' and paste your rules from: $SOURCE_FILE"
    echo ""
    warning "For project-level rules, you can create .cursorrules in your project directory"
}

# Sync to all tools without interactive menu (original behavior)
run_sync_all() {
    echo ""
    color_bold "Agent Rules Sync v${VERSION}"
    echo ""

    if [[ "$DRY_RUN" == true ]]; then
        warning "DRY RUN MODE - No changes will be made"
        echo ""
    fi

    local success_count=0
    local failure_count=0
    local skipped_count=0

    for tool in "${ALL_TOOLS[@]}"; do
        local tool_path
        if tool_path="$(get_tool_path "$tool")"; then
            if sync_to_tool "$tool" "$tool_path"; then
                ((success_count++))
            else
                ((failure_count++))
            fi
        else
            warning "Skipping unknown tool: $tool"
            ((failure_count++))
        fi
    done

    # Handle Cursor separately
    echo ""
    handle_cursor
    ((skipped_count++))

    # Display summary
    echo ""
    color_bold "Summary:"
    echo "  $(color_green "Success: $success_count")"
    [[ $failure_count -gt 0 ]] && echo "  $(color_red "Failed: $failure_count")"
    [[ $skipped_count -gt 0 ]] && echo "  $(color_yellow "Skipped: $skipped_count (manual update required)")"
    echo ""

    [[ $failure_count -eq 0 ]] && exit 0 || exit 1
}

# Interactive sync flow - let user select tools to sync
run_interactive_sync() {
    echo ""
    color_bold "Agent Rules Sync v${VERSION}"
    echo ""

    if [[ "$DRY_RUN" == true ]]; then
        warning "DRY RUN MODE - No changes will be made"
        echo ""
    fi

    # Build list of tools with their status
    local tool_options=()
    for tool in "${ALL_TOOLS[@]}"; do
        local tool_path
        if tool_path="$(get_tool_path "$tool")"; then
            if [[ -f "$tool_path" ]]; then
                tool_options+=("$tool (installed)")
            else
                tool_options+=("$tool (not installed)")
            fi
        fi
    done

    # Show multi-select menu
    if ! multi_select_menu "Select tools to sync (↑↓ move, Space toggle, a=all, d=none, Enter confirm, Esc cancel):" "${tool_options[@]}"; then
        info "Sync cancelled"
        exit 0
    fi

    if [[ -z "$MULTI_SELECT_RESULT" ]]; then
        info "No tools selected"
        exit 0
    fi

    # Sync selected tools
    local success_count=0
    local failure_count=0

    for idx in $MULTI_SELECT_RESULT; do
        local tool="${ALL_TOOLS[$idx]}"
        local tool_path
        if tool_path="$(get_tool_path "$tool")"; then
            if sync_to_tool "$tool" "$tool_path"; then
                ((success_count++))
            else
                ((failure_count++))
            fi
        fi
    done

    # Check if Cursor was selected (index 5 would be cursor if it was in ALL_TOOLS)
    # Since Cursor is not in ALL_TOOLS, we'll ask separately
    echo ""
    interactive_menu "Would you like instructions for Cursor (manual update required)?" "Yes, show instructions" "No, skip"
    if [[ $MENU_RESULT -eq 0 ]]; then
        echo ""
        handle_cursor
    fi

    # Display summary
    echo ""
    color_bold "Summary:"
    echo "  $(color_green "Success: $success_count")"
    [[ $failure_count -gt 0 ]] && echo "  $(color_red "Failed: $failure_count")"
    echo ""

    [[ $failure_count -eq 0 ]] && exit 0 || exit 1
}

# Main sync function
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_usage
                exit 0
                ;;
            --version|-v)
                show_version
                exit 0
                ;;
            --list-tools)
                list_tools
                exit 0
                ;;
            --list-backups)
                LIST_BACKUPS_MODE=true
                shift
                ;;
            --restore)
                RESTORE_MODE=true
                shift
                ;;
            --all)
                SYNC_ALL=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --no-backup)
                NO_BACKUP=true
                shift
                ;;
            --tool)
                if [[ -n "${2:-}" ]]; then
                    SPECIFIC_TOOL="$2"
                    shift 2
                else
                    error "Missing tool name after --tool"
                    exit 1
                fi
                ;;
            --source)
                if [[ -n "${2:-}" ]]; then
                    SOURCE_FILE="$2"
                    shift 2
                else
                    error "Missing path after --source"
                    exit 1
                fi
                ;;
            *)
                error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
    done

    # Handle list-backups mode
    if [[ "$LIST_BACKUPS_MODE" == true ]]; then
        list_all_backups
        exit 0
    fi

    # Handle restore mode
    if [[ "$RESTORE_MODE" == true ]]; then
        run_restore
        exit 0
    fi

    # Check if source file exists
    if [[ ! -f "$SOURCE_FILE" ]]; then
        error "Source file not found: $SOURCE_FILE"
        warning "Create an AGENTS.md file or specify a different source with --source"
        exit 1
    fi

    [[ "$VERBOSE" == true ]] && info "Using source file: $SOURCE_FILE"

    # If specific tool is provided, sync only that tool (non-interactive)
    if [[ -n "$SPECIFIC_TOOL" ]]; then
        echo ""
        color_bold "Agent Rules Sync v${VERSION}"
        echo ""

        if [[ "$DRY_RUN" == true ]]; then
            warning "DRY RUN MODE - No changes will be made"
            echo ""
        fi

        local tool_path
        if tool_path="$(get_tool_path "$SPECIFIC_TOOL")"; then
            if sync_to_tool "$SPECIFIC_TOOL" "$tool_path"; then
                echo ""
                color_bold "Summary:"
                echo "  $(color_green "Success: 1")"
                echo ""
                exit 0
            else
                echo ""
                color_bold "Summary:"
                echo "  $(color_red "Failed: 1")"
                echo ""
                exit 1
            fi
        else
            error "Unknown tool: $SPECIFIC_TOOL"
            echo ""
            echo "Available tools:"
            list_tools
            exit 1
        fi
    fi

    # If --all flag is provided, sync all tools without interactive menu
    if [[ "$SYNC_ALL" == true ]]; then
        run_sync_all
        exit 0
    fi

    # Default: Interactive mode
    run_interactive_sync
}

# Run main function
main "$@"
